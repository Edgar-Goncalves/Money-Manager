# Software Engineering Rules & Best Practices

All agents (including myself) working on this codebase MUST adhere to the following principles to ensure maintainability, scalability, and robustness.

## 1. SOLID Principles
- **Single Responsibility (SRP)**: Each class, function, or module should have one, and only one, reason to change. Avoid "God Objects."
- **Open/Closed (OCP)**: Software entities should be open for extension but closed for modification. Use composition and interfaces/protocols.
- **Liskov Substitution (LSP)**: Objects of a superclass should be replaceable with objects of its subclasses without breaking the application.
- **Interface Segregation (ISP)**: No client should be forced to depend on methods it does not use. Keep interfaces small and focused.
- **Dependency Inversion (DIP)**: Depend on abstractions, not concretions. High-level modules should not depend on low-level modules.

## 2. Clean Code & Software Craftsmanship
- **Meaningful Names**: Use descriptive and unambiguous names for variables, functions, and classes.
- **DRY (Don't Repeat Yourself)**: Abstract common logic into reusable components or utilities.
- **KISS (Keep It Simple, Stupid)**: Avoid over-engineering. Seek the simplest solution that works and remains maintainable.
- **YAGNI (You Ain't Gonna Need It)**: Don't implement features or complexity until they are actually needed.
- **Small Functions**: Functions should be small and do one thing well.

## 3. Web Development Standards
- **CSS Specificity**: Avoid using `!important` unless strictly necessary (e.g., overriding 3rd party styles). Prefer semantic classes and proper cascading.
- **Responsive Design**: Always prioritize mobile-first or highly responsive layouts.
- **Performance**: Optimize assets and minimize DOM manipulations.
- **Security**: Sanitize inputs and secret keys (e.g., use environment variables or secure storage).

## 4. Documentation & Git
- **Meaningful Commits**: Write descriptive commit messages summarizing *what* and *why*.
- **Code Comments**: Comment the "Why," not the "What." The code should be self-explanatory whenever possible.

---
*Failure to follow these rules will result in technical debt. Always refactor when you see an opportunity to improve the structure without breaking functionality.*
